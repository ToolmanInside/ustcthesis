% !TeX root = ../main.tex

\chapter{主要研究方法及技术路线}

\section{现有工具漏洞检测能力}

在开始进行实验之前，我们需要对现有工具的检测能力进行充分地调研。只有在了解现有工具的检测能力、检测特点的情况下，我们才能开始进行漏洞标准库的构建和新工具的研发工作。为此，我们调研了当下对Solidity的研究工作，有的工作来自于商业团队，有的来自于学术团队；有的工具已经开源，并具备一定的社区影响力，有的工具发表于计算机顶级国际会议，带来了巨大的科研价值。发表于国际会议的工作，有的没有开源，对于这些没有开源的工作，虽然有论文做详细的说明，但由于不能获取到源代码，我们没办法对系统的内核做更深一步的分析，所以这些工具尽管有一定的学术影响力，我们也只能放弃。对于已经开源的工作，有些工具的开发逻辑不够严谨，或者相关文档不够完备，这些工具我们虽然能取得它们的源代码，但由于无法清晰地分析系统实现，故这些工具我们也无法很好地去分析他们的检测原理和检测能力。综上，在经过我们的筛选后，我们对如下工具在主要漏洞上的检测能力做出了总结，并和我们的系统\textsc{Athena}做比较列于表\ref{tab:detection_capability}。

\begin{table}
  \centering\small
  \caption{现有工具对于主要漏洞的检测能力总结}
  \begin{tabular}{cccccc}
    \toprule
    % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
     & \textsc{Slither} & \textsc{Oyente} & \textsc{Smartcheck} & \textsc{Securify} & \textsc{Athena} \\
     \midrule
    可重入漏洞 & $\checkmark$ & $\checkmark$ & $\times$ & $\checkmark$ & $\checkmark$ \\
    意外异常漏洞 & $\checkmark$ & $\times$ & $\checkmark$ & $\times$ & $\checkmark$ \\
    低级调用漏洞 & $\checkmark$ & $\times$ & $\checkmark$ & $\times$ & $\checkmark$ \\
    自毁漏洞 & $\checkmark$ & $\times$ & $\times$ & $\times$ & $\checkmark$ \\
    \bottomrule
  \end{tabular}
  \label{tab:detection_capability}
\end{table}

上表所列的工具皆为静态分析工具，其中\textsc{Oyente}主要使用符号执行分析技术；\textsc{Securify}主要把代码转换成Datalog语言，并使用\textsc{Souffle}进行分析。\textsc{Slither}和\textsc{Smartcheck}采用的是传统的静态分析技术，即通过分析源代码得到程序的控制流图，并在控制流图上用预先设定好的匹配规则去寻找漏洞。从表中不难看出，使用传统静态分析技术的工具分析能力都比较不错，\textsc{Slither}支持我们提及的所有漏洞的检测，\textsc{Smartcheck}不支持两个漏洞的检测；而使用符号执行分析技术，包括使用其他静态分析技术的工具，对主要漏洞的支持都不太好，甚至只支持一个漏洞的检测。值得一提的是，这两个工具\textsc{Oyente}和\textsc{Securify}皆是在源代码编译之后产生的字节码上进行软件分析的，字节码的分析提供的信息更少，相比之下\textsc{Slither}和\textsc{Smartcheck}都是对源代码或者中间语言进行分析，故我们推测是由于技术路线的差异造成它们在不同漏洞上的分析难度不同，也就没办法支持所有漏洞的分析任务。

\section{使用克隆分析技术寻找漏洞代码}

在克隆代码分析技术中，按照代码相似的不同程度，我们可以把代码划分为以下几种克隆层次：
\begin{itemize}
  \item \textbf{第一类克隆：完全克隆。}这种克隆下层次下的相似代码之间完全相似，没有任何差异。
  \item \textbf{第二类克隆：重命名克隆。}这种克隆层次下的代码之间绝大部分相似，在类型、标识符、注释、空格之间有些许差异。
  \item \textbf{第三类克隆：重构克隆。}这种克隆层次下的相似代码之间具有结构层次的不同，例如缺少部分语句，多出部分语句，语句顺序不同等等。
  \item \textbf{第四类克隆：语义克隆。}这种克隆层次下的相似代码之间可能完全不同，但他们具有相同的语义，实现了相同的功能或流程。
\end{itemize}
从克隆层次的分类我们可以看出，第一类克隆和第二类克隆不涉及代码结构上的变化，因而能用比较简单的技术进行分析。在Kamiya等人的工作中\cite{ccfinder}，使用了基于标记的克隆分析技术来寻找克隆代码，将代码的关键部分转换为标记，再在标记上进行分析寻找。由于前两类克隆代码的分析并没有什么挑战，因此现在已经有很多这方面的工作。对于第三类克隆，因为代码之间出现了语句结构的差异，例如多的语句，少的语句等等，直接借助基于标记的克隆分析技术来寻找克隆代码可能会遇上很多困难。为了解决这一问题，有人提出了提取代码特征转换成特征向量，并在高维空间进行比较的办法\cite{deckard}，也有的工作提出使用软件的控制流图进行语句结构的比较\textcolor{red}{Add citation here}。而对于第四类克隆的分析，仍然是当前软件工程学界的一个有挑战的课题。有的工作提出使用深度学习算法进行代码语义的提取\textcolor{red}{Add ICST citation}，但仍有很大的局限性如学习算法的数据集匮乏，很难找到数量充足且质量上乘的训练材料。因此，在讨论克隆分析技术时，我们主要解决的是寻找前三类克隆的相似代码的问题。

针对以上三种代码克隆等级，之前的工作提出了很多不同粒度的解决方案：
\begin{enumerate}
  \item \textbf{基于标记粒度的克隆分析技术：}使用基于标记力度的克隆分析技术试图使用将代码语句转换成标记序列，然后再在标记序列上比较相似度。这其中最出名的工作有CP-Miner\cite{cpminer}。
  
  CP-Miner解析了程序代码，并使用了“最频繁子序列挖掘”算法对代码生成的标记序列进行比较。这个算法由CloSpan\cite{clospan}这篇工作提出。多亏了CloSpan这篇工作在改进算法运行效率方面的贡献，CP-Miner可以在大规模代码，如Linux内核代码下仍保持了较低的内存占用。但是，CP-Miner的运行时间复杂度在最坏情况下为$\mathcal{O}(n^{2})$，$n$为代码行数，运行耗时较长。除开在大规模代码下的效率问题，CP-Miner也容易产生很多误报，这个是由于他们激进的代码抽象策略及有筛选的遗产算法导致的。虽然CP-Miner的开发者认为CP-Miner在数据集上的表现不错，但很明显CP-Miner并没有在漏洞代码检测这项任务上有足够的可靠行。
  \item a
  \item a
  \item a
  \item a
\end{enumerate}

在我们观察了大量的智能合约软件代码过后，我们发现，在以太坊平台上存在着大量的代码克隆现象，代码相似度层级如下图所示\textcolor{red}{Add similarity figure}。我们推测这是由于Solidity代码无法引用代码引起的。很多智能合约软件直接复制已经存在的软件代码，稍加改动，如修改了交易地址，甚至不改动就添加到自己的代码中，参与自己软件的运行过程。很明显，这虽然方便了开发者，减轻了开发任务，但是直接拷贝代码的行为容易在无意间引入漏洞。在一个存在很多克隆代码的平台，要保证软件的平均安全等级是很困难的。Solidity研究团队推荐开发者拷贝或使用经过官方团队审计的接口代码，但是不推荐开发者拷贝其他任何代码。

针对以太坊平台如此严重的代码克隆现象，我们提出使用代码克隆分析技术来寻找漏洞的方法。在\textsc{VUDDY}\cite{vuddy}这篇工作中，研发团队使用